if (!window.hasObserver) {
	window.hasObserver = true;
	var observerTimeout = -1;
	var observerM = new MutationObserver(function (mutations, observer) {
	  clearTimeout(observerTimeout);
	  observerTimeout = setTimeout(function () {
		window.dispatchEvent(new Event('resize'));
	  }, 500);
	});
	observerM.observe(document.body, {
	  subtree: true,
	  childList: true,
	  attributes: true
	});
};
"use strict";

/**
 * @file
 * JS functionality for responsive tables inside CKeditor (Internet Explorer fix).
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_responsive_tables = {
    attach: function attach(context) {
      $(context).find('.paragraph--type--bp-simple table:not(table[responsivedisabled="true"])').once('ckeditor-table').each(function () {
        var table = $(this);
        var borderSettings = table.attr('border');

        if (borderSettings > 0) {
          table.addClass('has-border');
        } else {
          table.removeClass('has-border');
        }
      });
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

/**
 * @file
 * JS functionality for fixing new tab links.
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_new_tab_link = {
    attach: function attach(context) {
      $(context).find('.paragraph--type--bp-simple a[target="_blank"]').once("new-tab-link").on("click", function (e) {
        e.stopPropagation();
      });
    }
  };
})(window.jQuery, window.Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

Drupal.debounce = function (func, wait, immediate) {
  var timeout;
  var result;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        result = func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      result = func.apply(context, args);
    }

    return result;
  };
};;
"use strict";

/**
 * @file
 * JS functionality for fixing line-heights smaller than font-sizes in the CKEDITOR.
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_line_height = {
    attach: function attach(context) {
      var lineHeightStr = "line-height";
      $(context).find('.field--type-text-long span').once("line-height").each(function () {
        var span = $(this);
        var spanStyle = span.attr("style");

        if (spanStyle) {
          if (spanStyle.indexOf(lineHeightStr) > -1 && span.css('display') !== 'block') {
            span.css('display', 'block');
          }
        }
      });
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

// @codingStandardsIgnoreFile

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * @file
 * CKEditor plugin "BpButton" definition.
 */
(function ($, Drupal) {
  'use strict';

  /**
   * Attaches the bpButton behavior.
   *
   * @type {Drupal~behavior}
   *
   * @prop {Drupal~behaviorAttach} attach
   *   Attaches the bpButton behavior.
   */
  Drupal.behaviors.attsite_ckeditor_bpbutton_init = {
    attach: function attach(context, settings) {
      /** @var settings no inspection */
      $(context).find('.bpbutton').once('bpbutton-init').each(function () {
        Drupal.bpButton.init($(this));
      });
    }
  };

  /**
   * Class to wrap list of our functions which should help for plugin normal work.
   */
  Drupal.bpButton = new function () {

    /**
     * Storage for list of keys which will be used to style data.
     *
     * @return array
     */
    this.keys = function () {
      return [
        // Main tab.
       'font_size', 'font_weight', 'font_style', 'font_size_sub', 'font_weight_sub', 'font_style_sub', 'extra_class',
        // Style tab.
       'background', 'opacity', 'color', 'hover_background', 'hover_opacity', 'hover_color', 'min_width', 'max_width',
        // Border tab.
        'border_style', 'border_width', 'border_color', 'border_radius', 'hover_border_style', 'hover_border_width', 'hover_border_color', 'hover_border_radius',
        // Shadow tab.
        'shadow_shift_horizontal', 'shadow_shift_vertical', 'shadow_spread', 'shadow_blur', 'shadow_color', 'shadow_inset', 'hover_shadow_shift_horizontal', 'hover_shadow_shift_vertical', 'hover_shadow_spread', 'hover_shadow_blur', 'hover_shadow_color', 'hover_shadow_inset',
        // Gradient tab.
        'gradient_type', 'gradient_color_first', 'gradient_color_second', 'hover_gradient_type', 'hover_gradient_color_first', 'hover_gradient_color_second',
        // Spacing tab.
        'margin_top', 'margin_right', 'margin_bottom', 'margin_left', 'padding_top', 'padding_right', 'padding_bottom', 'padding_left',
      ];
    };

    /**
     * Function to get data for some element.
     *
     * @param $element
     *   jQuery element which should be used as storage.
     *
     * @returns object
     *   Element data.
     */
    this.getData = function ($element) {
      var rawData = $element.attr('data-bpbutton');
      var data = typeof rawData === 'undefined' ? {} : JSON.parse(rawData);

      return this.defaultData(data);
    };

    /**
     * Function to set data for some element.
     *
     * @param $element
     *   jQuery element which should be used as storage.
     * @param data
     *   Object of data to set to the element.
     *
     * @returns object
     *   Element data.
     */
    this.setData = function ($element, data) {
      $element.attr('data-bpbutton', JSON.stringify(this.defaultData(data)));
    };

    /**
     * Function to validate data object and it's default keys.
     *
     * @param data
     *   Object of data to validate.
     *
     * @returns object
     *   Element data.
     */
    this.defaultData = function (data) {
      data = _typeof(data) !== 'object' ? {} : data;

      // Default keys.
      var keys = this.keys();

      for (var key in keys) {
        data[keys[key]] = typeof data[keys[key]] === 'undefined' ? '' : data[keys[key]];
      }

      return data;
    };

    /**
     * Function to apply default styles to an element.
     *
     * @param $element
     *   jQuery element which should be used for styling.
     *
     * @returns void
     */
    this.styleDefault = function ($element) {
      this.style($element);
    };

    /**
     * Function to apply hover styles to an element.
     *
     * @param $element
     *   jQuery element which should be used for styling.
     *
     * @returns void
     */
    this.styleHover = function ($element) {
      this.style($element, 'hover');
    };

    /**
     * Function to apply styles to an element by prefix.
     *
     * @param $element
     *   jQuery element which should be used for styling.
     * @param prefix
     *   Parameters prefix string.
     *
     * @returns void
     */
    this.style = function ($element) {
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      var styleSettings = this.getData($element);

      if (prefix) {
        prefix += '_';
      }

      if (prefix === '') {
        // Not prefixed values.
        $element.css('margin-top', styleSettings[prefix + 'margin_top']);
        $element.css('margin-right', styleSettings[prefix + 'margin_right']);
        $element.css('margin-bottom', styleSettings[prefix + 'margin_bottom']);
        $element.css('margin-left', styleSettings[prefix + 'margin_left']);
        $element.css('padding-top', styleSettings[prefix + 'padding_top']);
        $element.css('padding-right', styleSettings[prefix + 'padding_right']);
        $element.css('padding-bottom', styleSettings[prefix + 'padding_bottom']);
        $element.css('padding-left', styleSettings[prefix + 'padding_left']);
        $element.css('min-width', styleSettings[prefix + 'min_width']);
        $element.css('max-width', styleSettings[prefix + 'max_width']);
        $('.text', $element).css('font-size', styleSettings[prefix + 'font_size']);
        $('.glyphicon', $element).css('font-size', styleSettings[prefix + 'font_size']);
        $('i', $element).css('font-size', styleSettings[prefix + 'font_size']);
        $('.text', $element).css('font-weight', styleSettings[prefix + 'font_weight']);
        $('.text', $element).css('font-style', styleSettings[prefix + 'font_style']);
        $('.subtext', $element).css('font-size', styleSettings[prefix + 'font_size_sub']);
        $('.subtext', $element).css('font-weight', styleSettings[prefix + 'font_weight_sub']);
        $('.subtext', $element).css('font-style', styleSettings[prefix + 'font_style_sub']);
      }

      $element.css('background-color', styleSettings[prefix + 'background']);
      $element.css('opacity', styleSettings[prefix + 'opacity']);
      $element.css('color', styleSettings[prefix + 'color']);
      $element.css('border-style', styleSettings[prefix + 'border_style']);
      $element.css('border-color', styleSettings[prefix + 'border_color']);
      $element.css('border-width', styleSettings[prefix + 'border_width']);
      $element.css('border-radius', styleSettings[prefix + 'border_radius']);
      $element.addClass(styleSettings['extra_class']);
      this.cssShadow($element, styleSettings, prefix);
      this.cssGradient($element, styleSettings, prefix);
    };

    /**
     * Function to set vendor prefixes for border radius.
     *
     * @param $element
     *   jQuery element which should be used for styling.
     * @param styleSettings
     *   Settings object.
     * @param prefix
     *   Parameters prefix string.
     */
    this.cssShadow = function ($element, styleSettings) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      // Prepare list of properties in proper order.
      var keys = ['shadow_inset', 'shadow_shift_horizontal', 'shadow_shift_vertical', 'shadow_blur', 'shadow_spread', 'shadow_color'];

      // Build shadow string.
      var shadow = '',
          value;

      for (var key in keys) {
        // Grab our value from list of properties.
        value = typeof styleSettings[prefix + keys[key]] === 'undefined' ? '' : styleSettings[prefix + keys[key]];

        // Inset value should be modified.
        if (keys[key] === 'shadow_inset') {
          value = value ? 'inset' : '';
        }

        // Insert extra space after each parameter except last one.
        if (keys[key] !== 'shadow_color') {
          value += ' ';
        }

        // Add new value to string.
        if (value) {
          shadow += value;
        }

        value = null;
      }

      // Apply styles.
      if (shadow) {
        $element.css('box-shadow', shadow);
      }
    };

    /**
     * Function to set vendor prefixes for gradient.
     *
     * @param $element
     *   jQuery element which should be used for styling.
     * @param styleSettings
     *   Settings object.
     * @param prefix
     *   Parameters prefix string.
     */
    this.cssGradient = function ($element, styleSettings) {
      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      // Prepare list of properties.
      var gradient_type = typeof styleSettings[prefix + 'gradient_type'] === 'undefined' ? '' : styleSettings[prefix + 'gradient_type'];
      var gradient_color_first = typeof styleSettings[prefix + 'gradient_color_first'] === 'undefined' ? '' : styleSettings[prefix + 'gradient_color_first'];
      var gradient_color_second = typeof styleSettings[prefix + 'gradient_color_second'] === 'undefined' ? '' : styleSettings[prefix + 'gradient_color_second'];

      // Defaults for cases when you will use horizontal gradient.
      var direction_moz_and_webkit = 'left';
      var direction_default = 'to right';
      var direction_dx = 1;
      var default_gradient_type = 'linear-gradient';

      // Check which variables we should use.
      switch (gradient_type) {
        // Vertical gradient.
        case 'vertical':
          direction_moz_and_webkit = 'top';
          direction_default = 'to bottom';
          direction_dx = 0;
          break;
        // Radial gradient.
        case 'radial':
          direction_moz_and_webkit = 'center, ellipse cover';
          direction_default = 'ellipse at center';
          default_gradient_type = 'radial-gradient';
          break;
        // Diagonal +45 degrees.
        case 'diagonal_plus':
          direction_moz_and_webkit = '45deg';
          direction_default = '45deg';
          break;
        // Diagonal -45 degrees.
        case 'diagonal_minus':
          direction_moz_and_webkit = '-45deg';
          direction_default = '135deg';
          break;
      }

      // Apply styles.
      $element.css('background', default_gradient_type + '(' + direction_default + ',' + gradient_color_first + ' 0%,' + gradient_color_second + ' 100%)');
    };

    /**
     * Initialize possibility to use bpButton.
     *
     * @param $element
     *   jQuery element to initialize.
     */
    this.init = function ($element) {
      // Process styles.
      this.styleDefault($element);
      $element.hover(function () {
        Drupal.bpButton.styleHover($(this));
      }, function () {
        Drupal.bpButton.styleDefault($(this));
      });
    };
  }();
})(jQuery, Drupal);
;
/**
 * @file
 * Initializes modification based on provided configuration.
 */

(function (AbsoluteHeightModifier) {

  'use strict';

  AbsoluteHeightModifier.apply = function (context, selector, media, config) {

    var element = context.querySelector(selector);
    if (!element) {
      return;
    }

    setHeight(element, media, config.height);

    window.addEventListener('resize', function () {
      setHeight(element, media, config.height);
    });

  };

  function setHeight(element, media, height) {

    if (window.matchMedia(media).matches) {
      element.style.height = (window.innerHeight * parseFloat(height) / 100) + 'px';
    }
    else {
      element.style.height = '';
    }

  }

})(window.AbsoluteHeightModifier = window.AbsoluteHeightModifier || {});
;
"use strict";

/**
 * @file
 * JS functionality for the Brightcove component - non fluid height resize.
 */
(function ($, Drupal) {
  "use strict";

  Drupal.behaviors.attsite_brightcove_non_fluid_resizer = {
    attach: function attach(context) {
      if (!window.BCNonFluidResizer) {
        var resizeFn = function resizeFn() {
          $('.vjs-non-fluid').each(function (i, e) {
            var el = $(e);
            var video = el.find('video');
            var width = video.attr('width');
            var height = video.attr('height');
            var ratio = width / height;

            if (el.parent().width() < video.prop('width')) {
              el.css('height', video.width() / ratio);
            } else {
              el.css('height', '');
            }
          });
        };

        window.BCNonFluidResizer = true;
        $(window).on('bcPlayerReady', function () {
          resizeFn();
        });
        $(window).on('resize', function () {
          resizeFn();
        });
      }
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

/**
 * @file
 * JS functionality for the Brightcove component - non fluid style.
 */
(function ($, Drupal) {
  "use strict";

  Drupal.behaviors.attsite_brightcove_non_fluid_style = {
    attach: function attach(context) {
      if (!window.BCSCResizer) {
        var resizeFn = function resizeFn() {
          setTimeout(function () {
            $('.attsite-bc-video-container.c-bc').each(function (i, e) {
              var video = $(e).find('video');
              var videoParent = video.parent();
              $(e).find('.sound-control-wrapper').css({
                'width': $(video).css('width'),
                'height': $(video).css('height'),
                'left': videoParent.offset().left - videoParent.parent().offset().left
              });
            });
          }, 1);
        };

        window.BCSCResizer = true;
        $(window).on('bcPlayerReady', function () {
          resizeFn();
        });
        $(window).on('resize', function () {
          resizeFn();
        });
      }
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

/**
 * @file
 * JS functionality for the Brightcove component.
 */
(function ($, Drupal, drupalSettings) {
  "use strict";

  var waitTime = 0;
  var waitCount = 0,
      maxWaitCount = 400;

  function wait(readyCondition, readyCallback) {
    if (readyCondition()) {
      readyCallback();
      waitCount = 0;
    } else {
      setTimeout(function () {
        if (++waitCount < maxWaitCount) {
          wait(readyCondition, readyCallback);
        } else {
          waitCount = 0;
        }
      }, waitTime);
    }
  }

  function waitVideoJsLoad(readyCallback) {
    wait(function () {
      return typeof videojs !== 'undefined';
    }, readyCallback);
  }

  function waitPlayerLoad(paragraphId, doneCallback) {
    wait(function () {
      return !!getPlayerForParagraph(paragraphId);
    }, doneCallback);
  }

  function getPlayerForParagraph(paragraphId) {
    var videoSettings = drupalSettings.att.brightcove[paragraphId],
        playerId = $(videoSettings.id).find('.video-js').attr('id');

    if (!playerId) {
      playerId = $(videoSettings.id).find('.video-js video').attr('id');
    }

    return videojs.getPlayer(playerId);
  }

  function playerLoadedEvent(el, videoSettings, $soundControl) {
    window.dispatchEvent(window.bcPlayerReady);

    if (!videoSettings.usePlayerSettings) {
      // Muting the video if option is selected.
      el.muted(videoSettings.muted); // Autoplaying the video if option is selected.

      el.autoplay(videoSettings.autoplay); // Looping the video if option is selected.

      el.loop(videoSettings.loop);

      if (videoSettings.muted) {
        $soundControl.addClass('fa-volume-mute');
      } else {
        $soundControl.addClass('fa-volume-up');
      }
    } // Showing the video controls if option is selected.


    el.controls(videoSettings.controls); // Setting the initial volume.

    el.volume(videoSettings.initialVolume / 100); // Setting the initial video time.

    el.currentTime(videoSettings.initialTime);
  }

  function pauseVideoInModals(bcPlayer, el) {
    // ATTSCMS-2196: Brightcove video autoplay issue in Imagery.
    // ATTSCMS-2247: Brightcove video autoplay issue in Slider Carousel and Media Gallery
    var elVid = $("#".concat(el.id_));
    var insideComponentModal = elVid.parents('.att-component-modal').length;
    var componentModalOpen = elVid.parents('.att-component-modal:not(.in)').length;
    var imageryModalContent = elVid.parents('.component-modal-content').length;
    var imagery = elVid.parents('.att-imagery').length;

    if (insideComponentModal && componentModalOpen || imageryModalContent && imagery) {
      setTimeout(function () {
        el.pause();
        bcPlayer.pause();
      }, 0);
    }
  }

  function initPlayerAndControls(bcPlayer, videoSettings, parent, $soundControl) {
    bcPlayer.ready(function () {
      playerLoadedEvent(this, videoSettings, $soundControl);
      pauseVideoInModals(bcPlayer, this);
    });
    bcPlayer.on('play', function () {
      parent.addClass('playing');
      pauseVideoInModals(bcPlayer, this);
    });
    bcPlayer.on('pause', function () {
      parent.removeClass('playing');
    });
    $soundControl.off('click').on('click', function () {
      if (bcPlayer.muted()) {
        bcPlayer.muted(false);
        $soundControl.removeClass('fa-volume-mute').addClass('fa-volume-up');
      } else {
        bcPlayer.muted(true);
        $soundControl.removeClass('fa-volume-up').addClass('fa-volume-mute');
      }
    });
    videoSettings.initialized = true;
  }

  function initPlayers() {
    $.each(drupalSettings.att.brightcove, function (paragraphId, videoSettings) {
      if (!$(videoSettings.id).length) {
        return;
      }

      if (videoSettings.initialized) {
        return;
      }

      if (!window.bcPlayerReady) {
        window.bcPlayerReady = new Event('bcPlayerReady');
      }

      waitPlayerLoad(paragraphId, function () {
        var bcPlayer = getPlayerForParagraph(paragraphId),
            $soundControl = $(videoSettings.id).find('.sound-control');
        initPlayerAndControls(bcPlayer, videoSettings, $(videoSettings.id), $soundControl);
      });
    });
  }

  Drupal.behaviors.attsite_vbtheme_component_brightcove = {
    attach: function attach(context) {
      if (!$('.attsite-bc-video-container').length) {
        return;
      }

      waitVideoJsLoad(initPlayers);
    }
  };

  Drupal.reInitPlayersInsideGallery = function () {
    var videos = [].concat(Array.prototype.slice.call(document.querySelectorAll('.slick-infinite-mode video')), Array.prototype.slice.call(document.querySelectorAll('.slick-infinite-mode video-js')));

    for (var i = 0; i < videos.length; i++) {
      var video = videos[i];
      var parent = $(video).parents('.paragraph--type--attsite-brightcove-video');
      var parentId = $(parent[0]).attr('id');
      var id = null;

      if (parentId) {
        id = parentId.split('vbp-')[1];
      } else {
        id = parent[0].className.split('modifiers-id-paragraph-')[1].split(' ')[0];
      }

      initVideoPlayer(video, id, $(parent[0]));
    }

    function initVideoPlayer(video, settingId, parent) {
      var videoSettings = drupalSettings.att.brightcove[settingId];
      var bcPlayer = videojs.getPlayer(video.id),
          $soundControl = parent.find('.sound-control');
      initPlayerAndControls(bcPlayer, videoSettings, parent, $soundControl);
    }
  };
})(window.jQuery, window.Drupal, window.drupalSettings);;
"use strict";

/**
 * @file
 * Initializes modification based on provided configuration.
 */
(function ($, StickyContainerModifier) {
  "use strict";

  StickyContainerModifier.apply = function (context, selector, media, config) {
    var stickyType = config.type;
    var stickyOffset = config.offset;
    var stickyZindex = config.zindex;
    var mediaQuery = media;
    var container = $(selector);
    var paragraphId = container.attr('id');
    var containerParent = container.parent('.field--item');

    var addModifier = function addModifier() {
      var mqMatcher = window.matchMedia(mediaQuery);
      var editorMode = $('body').hasClass('user-logged-in');

      if (!editorMode && mqMatcher.matches) {
        containerParent.css({
          position: 'sticky'
        });
        containerParent.css('z-index', stickyZindex);

        if (stickyType === 'top') {
          containerParent.css({
            top: stickyOffset + 'px'
          });
        } else {
          containerParent.css({
            bottom: stickyOffset + 'px'
          });
        }
      } else {
        containerParent.css({
          position: ''
        });
        containerParent.css({
          top: ''
        });
        containerParent.css('z-index', '');
      }
    };

    $(document).once('sticky-modifier' + paragraphId).ready(addModifier);
    $(window).once('sticky-modifier' + paragraphId).on('resize', addModifier);
  };
})(jQuery, window.StickyContainerModifier = window.StickyContainerModifier || {});;
"use strict";

/**
 * @file
 * JS functionality for Sticky Header component.
 */
// @codingStandardsIgnoreFile
(function ($, Drupal, debounce) {
  'use strict';

  Drupal.behaviors.attsite_vbtheme_component_sticky_header_v2 = {
    attach: function attach(context) {
      var header = $('.att-header-v2');
      var global = header.find('.att-navbar-global');
      var main = header.find('.att-navbar-main');
      var below = header.find('.att-navbar-below');
      var globalHeight = global.length ? global.outerHeight() : 0;
      var mainHeight = main.length ? main.outerHeight() : 0;
      var belowHeigth = below.length ? below.outerHeight() : 0;
      var onlyBelow = header.hasClass('att-navbar--sticky-below');
      var mainBelow = header.hasClass('att-navbar--sticky-main');
      var stickToBottom = header.hasClass('sticky-header-bottom');
      var stickyOverflow = header.hasClass('sticky-header--overlap');
      var target = onlyBelow ? below : main;
      var targetOffset = target.offset() && target.offset().top || 0;
      header.attr('data-target-offset', targetOffset);
      var body = $('body');
      var editorMode = body.hasClass('user-logged-in');

      if (onlyBelow) {
        !editorMode && stickyOverflow && header.css('margin-bottom', "-".concat(belowHeigth, "px"));
      } else if (mainBelow) {
        !editorMode && stickyOverflow && header.css('margin-bottom', "-".concat(belowHeigth + mainHeight, "px"));
      } else {
        !editorMode && stickyOverflow && header.css('margin-bottom', "-".concat(belowHeigth + mainHeight + globalHeight, "px"));
      }

      if (stickToBottom) {
        body.css('padding-bottom', header.height());
      }

      var isSticky = debounce(function () {
        var scrollTop = window.pageYOffset !== undefined ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;

        if (scrollTop >= targetOffset && scrollTop !== 0) {
          header.addClass("is-sticky");

          if (onlyBelow) {
            main.addClass("not-sticky");
            global.addClass("not-sticky");
          } else if (mainBelow) {
            global.addClass("not-sticky");
          }
        } else {
          header.removeClass("is-sticky");
          main.removeClass("not-sticky");
          below.removeClass("not-sticky");
          global.removeClass("not-sticky");
        }
      }, 10);
      $(document).scroll(isSticky);
      isSticky();
    }
  };
})(window.jQuery, window.Drupal, window.Drupal.debounce);;
"use strict";

/**
 * @file
 * JS functionality for the Header 2.0 component.
 */
(function ($, Drupal) {
  "use strict";

  Drupal.behaviors.attsite_vbtheme_component_header_v2 = {
    attach: function attach(context) {
      var headerV2 = $(".paragraph--type--attsite-header-v2", context);
      headerV2.once("header-v2").each(function () {
        var header = $(this);
        var localStyleSettings = header.hasClass("use-local-header-settings");
        var hasHamburger = header.find(".paragraph--type--attsite-hamburger-menu");
        var isSticky = header.hasClass("sticky-header");
        var sticksToBottom = header.hasClass("sticky-header-bottom");
        var targetOffset = header.attr('data-target-offset');

        if (hasHamburger.length) {
          header.addClass("has-hamburger");
        }

        ;

        function getMenuPosition(scrollTop) {
          var headerHeight = header.outerHeight();
          var valueTop = 0;
          var valueBottom = 0;

          if ($(window).width() < 767) {
            switch (headerHeight) {
              case 128:
                valueBottom = '-104px';
                valueTop = 'calc(100% + 24px)';
                break;

              case 104:
                valueBottom = '-104px';
                valueTop = '100%';
                break;

              case 96:
                valueBottom = '-72px';
                valueTop = 'calc(100% + 24px)';
                break;

              case 72:
                valueBottom = '-72px';
                valueTop = '100%';
                break;
            }
          }

          if (valueTop) {
            if (sticksToBottom && scrollTop >= targetOffset && scrollTop !== 0) {
              $(".att-navigation .navbar-collapse", this).css("transform", "translatey(" + valueBottom + ")");
            } else {
              $(".att-navigation .navbar-collapse", this).css("transform", "translatey(" + valueTop + ")");
            }
          } else {
            $(".att-navigation .navbar-collapse", this).removeAttr('style');
          }
        }

        if (isSticky) {
          $(document).on("scroll", function () {
            getMenuPosition($(window).scrollTop());
          });
        }

        $(window).on('resize', function () {
          getMenuPosition($(window).scrollTop());
        });
        getMenuPosition($(window).scrollTop());
        var toggler = header.find('.navbar-toggle.hamburger');
        toggler.on('click', function () {
          setTimeout(function () {
            getMenuPosition($(window).scrollTop());
          }, 0);
        });
        $(window).on('resize', function () {
          if ($(window).width() > 766 && toggler.length) {
            if (!toggler.hasClass('collapsed')) {
              toggler.click();
            }
          }
        });

        if (localStyleSettings) {
          var navBar = header.find(".att-navigation__menu");
          var blockNavStyle = header.find(".att-navigation__menu--block");
          var underlineNavStyle = header.find(".att-navigation__menu--underline");
          var localBlockStyle = header.hasClass("hover-style-block");
          var localUnderlineStyle = header.hasClass("hover-style-underline");

          if (blockNavStyle.length && localUnderlineStyle) {
            navBar.each(function () {
              navBar.removeClass("att-navigation__menu--block");
              navBar.addClass("att-navigation__menu--underline");
            });
          } else if (underlineNavStyle.length && localBlockStyle) {
            navBar.each(function () {
              navBar.removeClass("att-navigation__menu--underline");
              navBar.addClass("att-navigation__menu--block");
            });
          }
        }
      });
    }
  };
})(window.jQuery, window.Drupal);;
/**
 * @file
 * Initializes all modifications.
 */

(function ($, Drupal) {

  'use strict';

  Drupal.behaviors.modifiers = {

    attach: function attach(context, settings) {
      // Process only if there are some modifiers.
      if (typeof settings.modifiers !== 'undefined') {
        this.initAttributes(context, settings);
        this.initSettings(context, settings);
      }
    },

    initSettings: function (context, settings) {
      // Skip processing if there are no modifications.
      if (typeof settings.modifiers.settings !== 'undefined') {
        var modifications = [];

        // Group all modifications into single array.
        $.each(settings.modifiers.settings, function (index, group) {
          modifications = modifications.concat(group);
        });

        // Process all modifications.
        $.each(modifications, function (index, modification) {
          var callback = window[modification.namespace][modification.callback];
          if (typeof callback === 'function') {
            // Check number of callback arguments.
            if (callback.length > 3) {
              // Callback with context and selector for backward compatibility.
              callback(context, modification.selector, modification.media, modification.args);
            }
            else {
              // Limit elements by context.
              $(modification.selector).each(function () {
                if ($.contains(context, this)) {
                  callback(this, modification.media, modification.args);
                }
              });
            }
          }
        });
      }
    },

    initAttributes: function (context, settings) {
      // Skip processing if there are no attributes.
      if (typeof settings.modifiers.attributes !== 'undefined') {
        var attributes = {};

        // Group all attributes into single array.
        $.each(settings.modifiers.attributes, function (index, group) {
          $.each(group, function (media, selectors) {
            // Initialize array for this media.
            if (typeof attributes[media] === 'undefined') {
              attributes[media] = {};
            }
            $.each(selectors, function (selector, values) {
              attributes[media][selector] = values;
            });
          });
        });

        // Process all attributes immediately.
        this.toggleAttributes(context, attributes);

        var that = this;
        // Process all attributes again after resize.
        window.addEventListener('resize', function () {
          that.toggleAttributes(context, attributes);
        });
      }
    },

    toggleAttributes: function (context, attributes) {
      var enable = {};
      var disable = {};

      // Check all media queries validity and split selectors to sets.
      $.each(attributes, function (media, selectors) {
        if (window.matchMedia(media).matches) {
          // Fill these selectors for enabling.
          $.each(selectors, function (selector, values) {
            enable[selector] = values;
          });
        }
        else {
          // Fill these selectors for disabling.
          $.each(selectors, function (selector, values) {
            disable[selector] = values;
          });
        }
      });

      // Remove unwanted attributes from target objects.
      $.each(disable, function (selector, values) {
        // Limit elements by context.
        var elements = $(selector).filter(function () {
          return $.contains(context, this);
        });
        if (elements.length) {
          // Process all attributes.
          $.each(values, function (attribute, value) {
            if (attribute === 'class') {
              $.each(value, function (index, item) {
                elements.removeClass(item);
              });
            }
            else {
              elements.prop(attribute, null);
            }
          });
        }
      });

      // Set required attributes to target objects.
      $.each(enable, function (selector, values) {
        // Limit elements by context.
        var elements = $(selector).filter(function () {
          return $.contains(context, this);
        });
        if (elements.length) {
          // Process all attributes.
          $.each(values, function (attribute, value) {
            if (attribute === 'class') {
              $.each(value, function (index, item) {
                elements.addClass(item);
              });
            }
            else if (typeof value === 'object') {
              elements.prop(attribute, value.join(' '));
            }
            else {
              elements.prop(attribute, value);
            }
          });
        }
      });
    }
  };

})(jQuery, Drupal);
;
