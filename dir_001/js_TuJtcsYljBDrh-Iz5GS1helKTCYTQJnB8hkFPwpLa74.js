/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

(function ($, once) {
  var deprecatedMessageSuffix = "is deprecated in Drupal 9.3.0 and will be removed in Drupal 10.0.0. Use the core/once library instead. See https://www.drupal.org/node/3158256";
  var originalJQOnce = $.fn.once;
  var originalJQRemoveOnce = $.fn.removeOnce;

  $.fn.once = function jQueryOnce(id) {
    Drupal.deprecationError({
      message: "jQuery.once() ".concat(deprecatedMessageSuffix)
    });
    return originalJQOnce.apply(this, [id]);
  };

  $.fn.removeOnce = function jQueryRemoveOnce(id) {
    Drupal.deprecationError({
      message: "jQuery.removeOnce() ".concat(deprecatedMessageSuffix)
    });
    return originalJQRemoveOnce.apply(this, [id]);
  };

  var drupalOnce = once;

  function augmentedOnce(id, selector, context) {
    originalJQOnce.apply($(selector, context), [id]);
    return drupalOnce(id, selector, context);
  }

  function remove(id, selector, context) {
    originalJQRemoveOnce.apply($(selector, context), [id]);
    return drupalOnce.remove(id, selector, context);
  }

  window.once = Object.assign(augmentedOnce, drupalOnce, {
    remove: remove
  });
})(jQuery, once);;
"use strict";

/**
 * @file
 * JS functionality for moving the modal component to the body when the modal is opened
 */
(function ($) {
  "use strict";

  $(document).on("show.bs.modal", function (event) {
    var $modalTarget = $(event.target);
    $modalTarget.once("modal-moved").each(function () {
      var $modal = $(this);
      $modal.detach();
      $("body").append($modal);
    });
  });
})(window.jQuery);;
"use strict";

/**
 * @file
 * Behaviors for the attsite_vbtheme theme.
 */
(function ($, _, Drupal) {
  'use strict';

  var init = false;
  /**
   * @type {string[]} Domains to be considered internal.
   *
   * No link tracking will be fired when navigating between these!
   */

  var linkInternalFilters = ['javascript:', 'experience.att.com', 'watch.att.com', 'more.att.com', 'audiencenetwork.att.com']; // Event.composedPath

  (function (e, d, w) {
    if (!e.composedPath) {
      e.composedPath = function () {
        if (this.path) {
          return this.path;
        }

        var target = this.target;
        this.path = [];

        while (target.parentNode !== null) {
          this.path.push(target);
          target = target.parentNode;
        }

        this.path.push(d, w);
        return this.path;
      };
    }
  })(Event.prototype, document, window);

  Drupal.behaviors.attsite_analytics = {
    attach: function attach(context) {
      if (init || drupalSettings.user.uid != null && drupalSettings.user.uid != 0) {
        return;
      }

      init = true;
      var counter = 10;

      var isAnalyticsLoaded = function isAnalyticsLoaded() {
        return window.s && window.s.isReadyToTrack();
      };

      var updateEventTracking = function updateEventTracking() {
        document.addEventListener('click', function (event) {
          var path = event.path || event.composedPath && event.composedPath();
          var eventPath = path.slice(0, path.length - 5);
          var targetLocation = 'link location';
          var destinationUrl;
          var linkName;

          for (var i = 0; i < eventPath.length; i++) {
            var currentTag = eventPath[i];

            if (currentTag.tagName === 'A' && !destinationUrl) {
              destinationUrl = currentTag.href || undefined;
              linkName = currentTag.textContent.trim();
            }

            if (destinationUrl && currentTag.getAttribute('data-track')) {
              targetLocation = "".concat(targetLocation, " | ").concat(currentTag.getAttribute('data-track'));
            }

            if (currentTag.classList && currentTag.classList.contains('content')) {
              break;
            }
          }

          destinationUrl && linkClicked(linkName, destinationUrl, targetLocation);
        }, true);
      };

      var linkClicked = function linkClicked(linkName, destinationUrl, targetLocation) {
        // These props were removed from s.setupLinkTrack()
        // call in the analytics script, in order to fill them here.
        window.s.prop19 = destinationUrl;
        window.s.prop20 = targetLocation; // Manually trigger "Other click" link tracking, as the analytics script
        // only triggers for "real" external links (not part of att.com)

        if (isExternalUrl(destinationUrl)) {
          s.tl(true, 'o', linkName, {
            prop19: destinationUrl,
            prop20: targetLocation
          });
        }
      };

      var isExternalUrl = function isExternalUrl(url) {
        url = url.toLowerCase().replace(/(^https?:\/\/)|(^\/\/)/, '');

        for (var i = 0; i < linkInternalFilters.length; ++i) {
          var filter = linkInternalFilters[i].toLowerCase();

          if (url.match(new RegExp('^[^\/\?]*' + escapeRegExp(filter), 'i'))) {
            return false;
          }
        }

        return true;
      };

      var escapeRegExp = function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      };

      (function initializeTracking() {
        if (!isAnalyticsLoaded()) {
          if (counter-- > 0) {
            setTimeout(initializeTracking, 256);
          } else {
            console.log('Adobe DTM is not running properly. Please check if the js is loaded and working!');
          }
        } else {
          updateEventTracking();
        }
      })();
    }
  };
})(window.jQuery, window._, window.Drupal);;
"use strict";

/**
 * @file
 * Behaviors for the attsite_vbtheme theme.
 */
(function ($, Drupal) {
  'use strict';

  Drupal.behaviors.attsite_vbtheme = {
    attach: function attach(context) {
      // Vartheme subtheme JavaScript behaviors goes here.
      var scroll = new SmoothScroll('a[href*="#"]', {
        header: '.sticky-header',
        easing: 'easeInQuad',
        speedAsDuration: true
      });
      $('.att-lightbox-button').click(function () {
        var dataTarget = $(this).attr('data-target') + ' img';
        showBlazy(dataTarget);
      });
    }
  }; // Function to swap blazy data-src and src attributes.

  var showBlazy = function showBlazy(dataTarget) {
    $(dataTarget).attr('src', $(dataTarget).attr('data-src')).addClass('b-loaded');
    $('<style>.media--loading:before {display: none}</style>').appendTo('head');
  };
})(window.jQuery, window.Drupal);;
/**
 * @file
 * Bootstrap Popovers.
 */

var Drupal = Drupal || {};

(function ($, Drupal, Bootstrap) {
  "use strict";

  var $document = $(document);

  /**
   * Extend the Bootstrap Popover plugin constructor class.
   */
  Bootstrap.extendPlugin('popover', function (settings) {
    return {
      DEFAULTS: {
        animation: !!settings.popover_animation,
        autoClose: !!settings.popover_auto_close,
        enabled: settings.popover_enabled,
        html: !!settings.popover_html,
        placement: settings.popover_placement,
        selector: settings.popover_selector,
        trigger: settings.popover_trigger,
        title: settings.popover_title,
        content: settings.popover_content,
        delay: parseInt(settings.popover_delay, 10),
        container: settings.popover_container
      }
    };
  });

  /**
   * Bootstrap Popovers.
   *
   * @todo This should really be properly delegated if selector option is set.
   */
  Drupal.behaviors.bootstrapPopovers = {
    $activePopover: null,
    attach: function (context) {
      // Immediately return if popovers are not available.
      if (!$.fn.popover || !$.fn.popover.Constructor.DEFAULTS.enabled) {
        return;
      }

      var _this = this;

      $document
        .on('show.bs.popover', '[data-toggle=popover]', function () {
          var $trigger = $(this);
          var popover = $trigger.data('bs.popover');

          // Only keep track of clicked triggers that we're manually handling.
          if (popover.options.originalTrigger === 'click') {
            if (_this.$activePopover && _this.getOption('autoClose') && !_this.$activePopover.is($trigger)) {
              _this.$activePopover.popover('hide');
            }
            _this.$activePopover = $trigger;
          }
        })
        // Unfortunately, :focusable is only made available when using jQuery
        // UI. While this would be the most semantic pseudo selector to use
        // here, jQuery UI may not always be loaded. Instead, just use :visible
        // here as this just needs some sort of selector here. This activates
        // delegate binding to elements in jQuery so it can work it's bubbling
        // focus magic since elements don't really propagate their focus events.
        // @see https://www.drupal.org/project/bootstrap/issues/3013236
        .on('focus.bs.popover', ':visible', function (e) {
          var $target = $(e.target);
          if (_this.$activePopover && _this.getOption('autoClose') && !_this.$activePopover.is($target) && !$target.closest('.popover.in')[0]) {
            _this.$activePopover.popover('hide');
            _this.$activePopover = null;
          }
        })
        .on('click.bs.popover', function (e) {
          var $target = $(e.target);
          if (_this.$activePopover && _this.getOption('autoClose') && !$target.is('[data-toggle=popover]') && !$target.closest('.popover.in')[0]) {
            _this.$activePopover.popover('hide');
            _this.$activePopover = null;
          }
        })
        .on('keyup.bs.popover', function (e) {
          if (_this.$activePopover && _this.getOption('autoClose') && e.which === 27) {
            _this.$activePopover.popover('hide');
            _this.$activePopover = null;
          }
        })
      ;

      var elements = $(context).find('[data-toggle=popover]').toArray();
      for (var i = 0; i < elements.length; i++) {
        var $element = $(elements[i]);
        var options = $.extend({}, $.fn.popover.Constructor.DEFAULTS, $element.data());

        // Store the original trigger.
        options.originalTrigger = options.trigger;

        // If the trigger is "click", then we'll handle it manually here.
        if (options.trigger === 'click') {
          options.trigger = 'manual';
        }

        // Retrieve content from a target element.
        var target = options.target || $element.is('a[href^="#"]') && $element.attr('href');
        var $target = $document.find(target).clone();
        if (!options.content && $target[0]) {
          $target.removeClass('visually-hidden hidden').removeAttr('aria-hidden');
          options.content = $target.wrap('<div/>').parent()[options.html ? 'html' : 'text']() || '';
        }

        // Initialize the popover.
        $element.popover(options);

        // Handle clicks manually.
        if (options.originalTrigger === 'click') {
          // To ensure the element is bound multiple times, remove any
          // previously set event handler before adding another one.
          $element
            .off('click.drupal.bootstrap.popover')
            .on('click.drupal.bootstrap.popover', function (e) {
              $(this).popover('toggle');
              e.preventDefault();
              e.stopPropagation();
            })
          ;
        }
      }
    },
    detach: function (context) {
      // Immediately return if popovers are not available.
      if (!$.fn.popover || !$.fn.popover.Constructor.DEFAULTS.enabled) {
        return;
      }

      // Destroy all popovers.
      $(context).find('[data-toggle="popover"]')
        .off('click.drupal.bootstrap.popover')
        .popover('destroy')
      ;
    },
    getOption: function(name, defaultValue, element) {
      var $element = element ? $(element) : this.$activePopover;
      var options = $.extend(true, {}, $.fn.popover.Constructor.DEFAULTS, ($element && $element.data('bs.popover') || {}).options);
      if (options[name] !== void 0) {
        return options[name];
      }
      return defaultValue !== void 0 ? defaultValue : void 0;
    }
  };

})(window.jQuery, window.Drupal, window.Drupal.bootstrap);
;
/**
 * @file
 * Bootstrap Tooltips.
 */

var Drupal = Drupal || {};

(function ($, Drupal, Bootstrap) {
  "use strict";

  /**
   * Extend the Bootstrap Tooltip plugin constructor class.
   */
  Bootstrap.extendPlugin('tooltip', function (settings) {
    return {
      DEFAULTS: {
        animation: !!settings.tooltip_animation,
        enabled: settings.tooltip_enabled,
        html: !!settings.tooltip_html,
        placement: settings.tooltip_placement,
        selector: settings.tooltip_selector,
        trigger: settings.tooltip_trigger,
        delay: parseInt(settings.tooltip_delay, 10),
        container: settings.tooltip_container
      }
    };
  });

  /**
   * Bootstrap Tooltips.
   *
   * @todo This should really be properly delegated if selector option is set.
   */
  Drupal.behaviors.bootstrapTooltips = {
    attach: function (context) {
      // Immediately return if tooltips are not available.
      if (!$.fn.tooltip || !$.fn.tooltip.Constructor.DEFAULTS.enabled) {
        return;
      }

      var elements = $(context).find('[data-toggle="tooltip"]').toArray();
      for (var i = 0; i < elements.length; i++) {
        var $element = $(elements[i]);
        var options = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, $element.data());
        $element.tooltip(options);
      }
    },
    detach: function (context) {
      // Immediately return if tooltips are not available.
      if (!$.fn.tooltip || !$.fn.tooltip.Constructor.DEFAULTS.enabled) {
        return;
      }

      // Destroy all tooltips.
      $(context).find('[data-toggle="tooltip"]').tooltip('destroy');
    }
  };

})(window.jQuery, window.Drupal, window.Drupal.bootstrap);
;
"use strict";

/**
 * @file
 * JS functionality for responsive tables inside CKeditor (Internet Explorer fix).
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_responsive_tables = {
    attach: function attach(context) {
      $(context).find('.paragraph--type--bp-simple table:not(table[responsivedisabled="true"])').once('ckeditor-table').each(function () {
        var table = $(this);
        var borderSettings = table.attr('border');

        if (borderSettings > 0) {
          table.addClass('has-border');
        } else {
          table.removeClass('has-border');
        }
      });
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

/**
 * @file
 * JS functionality for fixing new tab links.
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_new_tab_link = {
    attach: function attach(context) {
      $(context).find('.paragraph--type--bp-simple a[target="_blank"]').once("new-tab-link").on("click", function (e) {
        e.stopPropagation();
      });
    }
  };
})(window.jQuery, window.Drupal);;
"use strict";

/**
 * @file
 * JS functionality for fixing line-heights smaller than font-sizes in the CKEDITOR.
 */
(function ($, Drupal) {
  Drupal.behaviors.attsite_line_height = {
    attach: function attach(context) {
      var lineHeightStr = "line-height";
      $(context).find('.field--type-text-long span').once("line-height").each(function () {
        var span = $(this);
        var spanStyle = span.attr("style");

        if (spanStyle) {
          if (spanStyle.indexOf(lineHeightStr) > -1 && span.css('display') !== 'block') {
            span.css('display', 'block');
          }
        }
      });
    }
  };
})(window.jQuery, window.Drupal);;
/**
* DO NOT EDIT THIS FILE.
* See the following change record for more information,
* https://www.drupal.org/node/2815083
* @preserve
**/

Drupal.debounce = function (func, wait, immediate) {
  var timeout;
  var result;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var context = this;

    var later = function later() {
      timeout = null;

      if (!immediate) {
        result = func.apply(context, args);
      }
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);

    if (callNow) {
      result = func.apply(context, args);
    }

    return result;
  };
};;
"use strict";

/**
 * @file
 * JS functionality for the Brightcove component.
 */
(function ($, Drupal, drupalSettings) {
  "use strict";

  var waitTime = 0;
  var waitCount = 0,
      maxWaitCount = 400;

  function wait(readyCondition, readyCallback) {
    if (readyCondition()) {
      readyCallback();
      waitCount = 0;
    } else {
      setTimeout(function () {
        if (++waitCount < maxWaitCount) {
          wait(readyCondition, readyCallback);
        } else {
          waitCount = 0;
        }
      }, waitTime);
    }
  }

  function waitVideoJsLoad(readyCallback) {
    wait(function () {
      return typeof videojs !== 'undefined';
    }, readyCallback);
  }

  function waitPlayerLoad(paragraphId, doneCallback) {
    wait(function () {
      return !!getPlayerForParagraph(paragraphId);
    }, doneCallback);
  }

  function getPlayerForParagraph(paragraphId) {
    var videoSettings = drupalSettings.att.brightcove[paragraphId],
        playerId = $(videoSettings.id).find('.video-js').attr('id');

    if (!playerId) {
      playerId = $(videoSettings.id).find('.video-js video').attr('id');
    }

    return videojs.getPlayer(playerId);
  }

  function playerLoadedEvent(el, videoSettings, $soundControl) {
    window.dispatchEvent(window.bcPlayerReady);

    if (!videoSettings.usePlayerSettings) {
      // Muting the video if option is selected.
      el.muted(videoSettings.muted); // Autoplaying the video if option is selected.

      el.autoplay(videoSettings.autoplay); // Looping the video if option is selected.

      el.loop(videoSettings.loop);

      if (videoSettings.muted) {
        $soundControl.addClass('fa-volume-mute');
      } else {
        $soundControl.addClass('fa-volume-up');
      }
    } // Showing the video controls if option is selected.


    el.controls(videoSettings.controls); // Setting the initial volume.

    el.volume(videoSettings.initialVolume / 100); // Setting the initial video time.

    el.currentTime(videoSettings.initialTime);
  }

  function pauseVideoInModals(bcPlayer, el) {
    // ATTSCMS-2196: Brightcove video autoplay issue in Imagery.
    // ATTSCMS-2247: Brightcove video autoplay issue in Slider Carousel and Media Gallery
    var elVid = $("#".concat(el.id_));
    var insideComponentModal = elVid.parents('.att-component-modal').length;
    var componentModalOpen = elVid.parents('.att-component-modal:not(.in)').length;
    var imageryModalContent = elVid.parents('.component-modal-content').length;
    var imagery = elVid.parents('.att-imagery').length;

    if (insideComponentModal && componentModalOpen || imageryModalContent && imagery) {
      setTimeout(function () {
        el.pause();
        bcPlayer.pause();
      }, 0);
    }
  }

  function initPlayerAndControls(bcPlayer, videoSettings, parent, $soundControl) {
    bcPlayer.ready(function () {
      playerLoadedEvent(this, videoSettings, $soundControl);
      pauseVideoInModals(bcPlayer, this);
    });
    bcPlayer.on('play', function () {
      parent.addClass('playing');
      pauseVideoInModals(bcPlayer, this);
    });
    bcPlayer.on('pause', function () {
      parent.removeClass('playing');
    });
    $soundControl.off('click').on('click', function () {
      if (bcPlayer.muted()) {
        bcPlayer.muted(false);
        $soundControl.removeClass('fa-volume-mute').addClass('fa-volume-up');
      } else {
        bcPlayer.muted(true);
        $soundControl.removeClass('fa-volume-up').addClass('fa-volume-mute');
      }
    });
    videoSettings.initialized = true;
  }

  function initPlayers() {
    $.each(drupalSettings.att.brightcove, function (paragraphId, videoSettings) {
      if (!$(videoSettings.id).length) {
        return;
      }

      if (videoSettings.initialized) {
        return;
      }

      if (!window.bcPlayerReady) {
        window.bcPlayerReady = new Event('bcPlayerReady');
      }

      waitPlayerLoad(paragraphId, function () {
        var bcPlayer = getPlayerForParagraph(paragraphId),
            $soundControl = $(videoSettings.id).find('.sound-control');
        initPlayerAndControls(bcPlayer, videoSettings, $(videoSettings.id), $soundControl);
      });
    });
  }

  Drupal.behaviors.attsite_vbtheme_component_brightcove = {
    attach: function attach(context) {
      if (!$('.attsite-bc-video-container').length) {
        return;
      }

      waitVideoJsLoad(initPlayers);
    }
  };

  Drupal.reInitPlayersInsideGallery = function () {
    var videos = [].concat(Array.prototype.slice.call(document.querySelectorAll('.slick-infinite-mode video')), Array.prototype.slice.call(document.querySelectorAll('.slick-infinite-mode video-js')));

    for (var i = 0; i < videos.length; i++) {
      var video = videos[i];
      var parent = $(video).parents('.paragraph--type--attsite-brightcove-video');
      var parentId = $(parent[0]).attr('id');
      var id = null;

      if (parentId) {
        id = parentId.split('vbp-')[1];
      } else {
        id = parent[0].className.split('modifiers-id-paragraph-')[1].split(' ')[0];
      }

      initVideoPlayer(video, id, $(parent[0]));
    }

    function initVideoPlayer(video, settingId, parent) {
      var videoSettings = drupalSettings.att.brightcove[settingId];
      var bcPlayer = videojs.getPlayer(video.id),
          $soundControl = parent.find('.sound-control');
      initPlayerAndControls(bcPlayer, videoSettings, parent, $soundControl);
    }
  };
})(window.jQuery, window.Drupal, window.drupalSettings);;
"use strict";

/**
 * @file
 * JS functionality for Dropdown component.
 */
(function ($, Drupal) {
  'use strict';

  Drupal.behaviors.attsite_vbtheme_component_dropdown = {
    attach: function attach(context) {
      var navigationMenu = $(context).find(".att-navigation__menu");
      var aLink = navigationMenu.find('.dropdown-toggle');
      var buttons = navigationMenu.find('.dropdown-arrow');

      function setArrowPadding() {
        // setting the button's padding from the a link item, because it is configurable by the theme.
        // buttons.css('padding', aLink.css('padding')); We need not to use the shorter version because of Firefox bug
        buttons.css('padding-left', aLink.css('padding-left'));
        buttons.css('padding-right', aLink.css('padding-right'));
        buttons.css('padding-top', aLink.css('padding-top'));
        buttons.css('padding-bottom', aLink.css('padding-bottom'));
      }

      function clearActiveMenuItem() {
        // With links containing only a hash the Drupal generates wrong data-drupal-link-system-path value (<front>).
        // Because of this the wrong menu item gets the .is-active class. So we remove the class in this case.
        var emptyLinks = aLink.filter('[href^="#"],[href=""]');
        emptyLinks.removeAttr('href').addClass('no-link').removeClass('is-active').removeAttr('data-drupal-link-system-path');
      }

      function buildExaminedLocation(location) {
        return location.host + location.pathname;
      }

      function setActiveMenuItem() {
        clearActiveMenuItem();
        var menuLinks = navigationMenu.find('a');
        var location = buildExaminedLocation(document.location);

        if (location.substr(-1) === '/') {
          location = location.substr(0, location.length - 1);
        } // We have to set the active menu by matching the current location, because in production the menu links
        // are absolute URL-s, and Drupal does not recognize them as internal routes.


        var locationRegex = new RegExp('^' + location + '/?$');
        menuLinks.each(function () {
          if (locationRegex.test(buildExaminedLocation(this))) {
            var activeLink = $(this);
            activeLink.addClass('is-active'); // Set parent to active

            activeLink.parents('li.dropdown:eq(0)').find('.dropdown-toggle').addClass('is-active');
          }
        });
      }

      buttons.click(function () {
        var $this = $(this);
        var parentLiWrapper = $this.closest('li');

        if (parentLiWrapper.hasClass("open")) {
          parentLiWrapper.removeClass("open");
        } else {
          parentLiWrapper.addClass("open"); // if needed to close the others use: .siblings().removeClass('open');
        }
      });
      setArrowPadding();
      $(window).resize(function () {
        setArrowPadding();
      });
      setActiveMenuItem();
    }
  };
})(window.jQuery, window.Drupal);;
/**
 * @file
 * Initializes all modifications.
 */

(function ($, Drupal) {

  'use strict';

  Drupal.behaviors.modifiers = {

    attach: function attach(context, settings) {
      // Process only if there are some modifiers.
      if (typeof settings.modifiers !== 'undefined') {
        this.initAttributes(context, settings);
        this.initSettings(context, settings);
      }
    },

    initSettings: function (context, settings) {
      // Skip processing if there are no modifications.
      if (typeof settings.modifiers.settings !== 'undefined') {
        var modifications = [];

        // Group all modifications into single array.
        $.each(settings.modifiers.settings, function (index, group) {
          modifications = modifications.concat(group);
        });

        // Process all modifications.
        $.each(modifications, function (index, modification) {
          var callback = window[modification.namespace][modification.callback];
          if (typeof callback === 'function') {
            // Check number of callback arguments.
            if (callback.length > 3) {
              // Callback with context and selector for backward compatibility.
              callback(context, modification.selector, modification.media, modification.args);
            }
            else {
              // Limit elements by context.
              $(modification.selector).each(function () {
                if ($.contains(context, this)) {
                  callback(this, modification.media, modification.args);
                }
              });
            }
          }
        });
      }
    },

    initAttributes: function (context, settings) {
      // Skip processing if there are no attributes.
      if (typeof settings.modifiers.attributes !== 'undefined') {
        var attributes = {};

        // Group all attributes into single array.
        $.each(settings.modifiers.attributes, function (index, group) {
          $.each(group, function (media, selectors) {
            // Initialize array for this media.
            if (typeof attributes[media] === 'undefined') {
              attributes[media] = {};
            }
            $.each(selectors, function (selector, values) {
              attributes[media][selector] = values;
            });
          });
        });

        // Process all attributes immediately.
        this.toggleAttributes(context, attributes);

        var that = this;
        // Process all attributes again after resize.
        window.addEventListener('resize', function () {
          that.toggleAttributes(context, attributes);
        });
      }
    },

    toggleAttributes: function (context, attributes) {
      var enable = {};
      var disable = {};

      // Check all media queries validity and split selectors to sets.
      $.each(attributes, function (media, selectors) {
        if (window.matchMedia(media).matches) {
          // Fill these selectors for enabling.
          $.each(selectors, function (selector, values) {
            enable[selector] = values;
          });
        }
        else {
          // Fill these selectors for disabling.
          $.each(selectors, function (selector, values) {
            disable[selector] = values;
          });
        }
      });

      // Remove unwanted attributes from target objects.
      $.each(disable, function (selector, values) {
        // Limit elements by context.
        var elements = $(selector).filter(function () {
          return $.contains(context, this);
        });
        if (elements.length) {
          // Process all attributes.
          $.each(values, function (attribute, value) {
            if (attribute === 'class') {
              $.each(value, function (index, item) {
                elements.removeClass(item);
              });
            }
            else {
              elements.prop(attribute, null);
            }
          });
        }
      });

      // Set required attributes to target objects.
      $.each(enable, function (selector, values) {
        // Limit elements by context.
        var elements = $(selector).filter(function () {
          return $.contains(context, this);
        });
        if (elements.length) {
          // Process all attributes.
          $.each(values, function (attribute, value) {
            if (attribute === 'class') {
              $.each(value, function (index, item) {
                elements.addClass(item);
              });
            }
            else if (typeof value === 'object') {
              elements.prop(attribute, value.join(' '));
            }
            else {
              elements.prop(attribute, value);
            }
          });
        }
      });
    }
  };

})(jQuery, Drupal);
;
